# JS异步

何为异步？

代码在执行的过程中，会遇到一些无法立即处理的任务，例如：
- 计时完成后需要执行的任务 -- `setTimeout`、`setInterval`
- 网络通信完成后需要执行的任务 -- `XHR`、`Fetch`
- 用户操作后需要执行的任务 -- `addEventListener`

如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于`阻塞`状态，从而导致浏览器`卡死`。

基于以上的问题，就出现了JS的事件循环机制。

## 事件循环
事件循环的机制就在渲染主线程中执行。

- 最开始的时候，渲染主线程会进入一个无限循环。
- 每一次循环会检查消息队列中是否有任务存在，如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。
- 其他所有线程(包括其他进程的线程)，可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。

整个过程，被称为事件循环(消息循环)。


## 如何理解JS异步

JS是一门单线程语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程承担着诸多的工作，例如渲染页面、执行JS等等。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死的现象。

所以浏览器采用异步的方法来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。


## 经典问题

```js
var h1 = document.querySelector('h1');
var btn = document.quertSelector('button');

function delay(duration) {
    var start = Date.now();
    while (Date.now() - start < duration) {}
}

btn.onclick = function () {
    h1.textContent = 'xdd';
    delay(3000);
}
```

点击按钮后，3s过后页面上的元素才会重新绘制成xdd。

用事件循环的机制来说明：
- 用户点击按钮，执行方法，将h1.textContent 设置为'xdd'。
- 修改html的元素，会导致页面重新渲染，此时需要开启一个任务去做渲染的操作，将任务添加到事件队列中。
- 执行3s的死循环，按钮的点击事件执行完毕。
- 渲染主线程去事件队列中查找任务，取出刚刚生成的渲染任务，进行渲染。



## 优先级

任务是没有优先级的，在消息队列中先进先出。但消息队列是有优先级的。

根据w3c最新解释：
- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
- 浏览器必须准备好一个微队列，微队列的任务优先所有其他任务执行。

https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

